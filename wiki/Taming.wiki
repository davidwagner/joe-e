#summary What taming is and how it works in Joe-E.  How to modify the taming database.

=Introduction=
The Java library defines many static methods that have side
effects on the outside world, as well as many constructors
that create objects permitting similar effects. This is a
major source of ambient authority in Java. For example, File
has a constructor that takes a string and returns an object
representing the file with that name. The resulting object
can be used to read, write, or delete the named file. Absent
explicit access control by the Java security manager or
the operating system, this allows any Java code full control
over the filesystem. In Joe-E, we wish to ensure that
code can only have access to a file if a capability for the file
(or a superdirectory) is within that code’s dynamic scope.
Consequently, we must not allow the aforementioned File
constructor in Joe-E’s global scope.

We define a subset of the Java libraries that includes only
those constructors, methods, and fields that are compatible
with the principle that all privileges must be granted via a
capability. We call this activity taming, because it turns an
unruly class library into a capability-secure subset. The Joe-E
verifier restricts Joe-E programs so they can mention only classes,
constructors, methods, and fields in this tamed subset. If
the source code mentions anything outside of this subset,
the Joe-E verifier ﬂags this as an error.  The taming policy
specifies the subset of classes, constructors, methods, and
fields from the Java libraries that Joe-E programs are permitted
to mention.

=Taming Policy=
By default, everything starts off being disabled for use by Joe-E code.  We have only enabled methods from the library after manual review of their documentated behavior.  So far, our effort has focused on basic, common classes, primarily in java.lang and java.util.

For things like data structures that don't relate to the outside world, a method can be safely enabled if it is:
- deterministic, as defined in the [http://www.cs.berkeley.edu/~amettler/pure-ccs08.pdf purity paper]
- has effects, if any, only on the method's arguments (including the this pointer)

For classes that represent external resources like filesystems or network connections (or Java-specific ones like its memory manager or other global- or thread-scoped resources), things are trickier. Essentially, any method that has any kind of elevated privilege (access to state or effects not possible otherwise), must require an explicit object reference that acts as a capability to authorize that method's invocation.  For example, to read or write data from a file, one needs a java.io.File object designating the file that one can access. 

=Taming Implementation=
Taming decisions are contained in the taming database.  The taming database consists of a set of a hierarchy of directories representing packages, and within each package's directory, a set of files for each class that has an entry in the taming database.

The safej files are used by the verifier when checking that code is valid Joe-E.  They are also used to generate the file org.joe_e.Policy.java, which is the runtime version of the taming database used for runtime checks of honorary implementation relationships and by Joe-E's wrapped reflection API to verify that only tamed members are invoked.  This file can be generated and automatically kept up-to-date with the current content of the safej taming database by creating an Eclipse project with the option "Automatically build Policy class" enabled in it's project-specific Preferences.  In order to avoid defining the same class twice, only one project in a multi-project application should have this option enabled.

==Customizing the taming database==
How to customize the taming database?  Very carefully: a bad taming decision could violate the object-capability properties Joe-E ensures.  You can enable additional methods (or honorary implementation relationships) by using a custom version of the taming database (.safej files).  These files follow a simple format based on s-expressions, which can be inferred from the example safej files provided.

If no .safej file exists for a class, that class's name cannot be referenced in any way in a Joe-E verified source file.  If you'd like to make use of the class, you will need to make a .safej file for it.  This can be done manually, but is tedious and error-prone.  The Joe-E eclipse plugin has code to automatically generate a skeleton .safej file for a class or for all classes in a pacakge, but this functionality currently lacks a user interface.

If you build the verifier from source, however, you can hack in a call to this code.  To do so, uncomment and appropriately modify the block at line 37 of SafeJImport.java in package org.joe_e.eclipse.  When the modified version of the Joe-E plugin is run, this will cause the new files to be generated the next time you load the verifier for a project.  (If the verifier is already running, you can force a reload by disabling and re-enabling the verifier for a project).