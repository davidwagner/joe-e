#summary What taming is and how it works in Joe-E.  How to modify the taming database.

=Introduction=
The Java library defines many static methods that have side
effects on the outside world, as well as many constructors
that create objects permitting similar effects. This is a
major source of ambient authority in Java. For example, File
has a constructor that takes a string and returns an object
representing the file with that name. The resulting object
can be used to read, write, or delete the named file. Absent
explicit access control by the Java security manager or
the operating system, this allows any Java code full control
over the filesystem. In Joe-E, we wish to ensure that
code can only have access to a file if a capability for the file
(or a superdirectory) is within that code’s dynamic scope.
Consequently, we must not allow the aforementioned File
constructor in Joe-E’s global scope.

We define a subset of the Java libraries that includes only
those constructors, methods, and fields that are compatible
with the principle that all privileges must be granted via a
capability. We call this activity taming, because it turns an
unruly class library into a capability-secure subset. The Joe-E
verifier restricts Joe-E programs so they can mention only classes,
constructors, methods, and fields in this tamed subset. If
the source code mentions anything outside of this subset,
the Joe-E verifier ﬂags this as an error.  The taming policy
specifies the subset of classes, constructors, methods, and
fields from the Java libraries that Joe-E programs are permitted
to mention.

=Taming Policy=
The Joe-E taming policy is a whitelist.
By default, everything starts off being disabled for use by Joe-E code.  We only enable methods from the Java library after manual review of their documented behavior.  So far, our effort has focused on basic, common classes, primarily in java.lang and java.util.

For libraries like data structures that don't interact with the outside world, a method can be safely enabled if:
  * it is deterministic, as defined in the [http://www.cs.berkeley.edu/~amettler/pure-ccs08.pdf purity paper], and
  * its side effects, if any, are limited to only objects reachable from the method's arguments (including the this pointer).

For classes that represent external resources like filesystems or network connections (or Java-specific shared entities like the Java memory manager or other global- or thread-scoped resources), things are trickier. Essentially, any method that has any kind of elevated privilege (access to state or ability to cause side effects not possible otherwise) must require an explicit object reference that acts as a capability to authorize that method's invocation.  For example, it should only be possible to read or write data from a file if one has a java.io.File object designating the file to be accessed; we must make sure the taming policy does not expose any Java library method that violates this security property.

Our approach to taming is based upon the use of taming in the E programming
language; for more on taming, read about E's [http://www.combex.com/papers/darpa-review/security-review.html#taming use of taming and safej files] and [http://www.erights.org/elib/legacy/taming.html the criteria E uses for taming].  However, our taming decisions were made independently from E; we borrow concepts, but not E's taming database.

=Taming Implementation=
Taming decisions are contained in the taming database.  The taming database consists of a set of a hierarchy of directories representing packages, and within each package's directory, a safej file for each class that has an entry in the taming database.  For example, the taming policy for `java.io.File` can be found in `safej/java/io/File.safej`.

Each safej file records several kinds of information:
  * The static fields, static methods, and constructors that Joe-E code is allowed to mention are listed in the `static(...)` portion of the safej file.
  * The instance fields and instance methods that Joe-E code is allowed to mention are listed in the `instance(...)` portion of the safej file.
  * Any honorary implementation relationships are listed in the `honorary(...)` portion of the safej file.  For instance, `java.lang.String` is treated by Joe-E as honorarily Powerless and honorarily Selfless; this fact is recorded in `safej/java/lang/String.java` in the `honorary(...)` clause.

The safej files are used by the Joe-E verifier.  They are also used to generate the file `org.joe_e.Policy.java`, which is a runtime copy of the taming database used for runtime checks of honorary implementation relationships and by Joe-E's wrapped reflection API to verify that only tamed members are invoked.  This file can be generated and automatically kept up-to-date with the current content of the safej taming database by creating an Eclipse project with the option "Automatically build Policy class" enabled in it's project-specific Preferences.  In order to avoid defining the same class twice, only one project in a multi-project application should have this option enabled.

==Customizing the taming database==
How to customize the taming database?  Very carefully: a bad taming decision could violate the object-capability properties Joe-E ensures.  You can enable additional methods (or honorary implementation relationships) by using a custom version of the taming database (.safej files).  These files follow a simple format based on s-expressions, which can be inferred from the example safej files provided.

If no .safej file exists for a class, that class's name cannot be referenced in any way in a Joe-E verified source file.  If you'd like to make use of the class, you will need to make a .safej file for it.  This can be done manually, but is tedious and error-prone.  The Joe-E eclipse plugin has code to automatically generate a skeleton .safej file for a class or for all classes in a pacakge, but this functionality currently lacks a user interface.

If you build the verifier from source, however, you can hack in a call to this code.  To do so, uncomment and appropriately modify the block at line 37 of SafeJImport.java in package org.joe_e.eclipse.  When the modified version of the Joe-E plugin is run, this will cause the new files to be generated the next time you load the verifier for a project.  (If the verifier is already running, you can force a reload by disabling and re-enabling the verifier for a project).